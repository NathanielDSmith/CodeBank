{"version":3,"file":"static/js/4627.443805b0.chunk.js","mappings":"kIAEA,MA4RA,EA5R0C,CACxC,CACEA,MAAO,0BACPC,SAAU,CACR,CACED,MAAO,0BACPE,KAAK,2sBA4BP,CACEF,MAAO,mBACPE,KAAK,quBAgCX,CACEF,MAAO,kCACPC,SAAU,CACR,CACED,MAAO,mBACPE,KAAK,gpBAuBP,CACEF,MAAO,qBACPE,KAAK,2zBAuCX,CACEF,MAAO,oBACPC,SAAU,CACR,CACED,MAAO,yBACPE,KAAK,wtBAiCP,CACEF,MAAO,4BACPE,KAAK,4lBA2BX,CACEF,MAAO,wBACPC,SAAU,CACR,CACED,MAAO,kBACPE,KAAK,+0BAsCP,CACEF,MAAO,8BACPE,KAAK,6kB","sources":["data/array/advanced.ts"],"sourcesContent":["import { ContentSection } from '../../types';\r\n\r\nconst advancedContent: ContentSection[] = [\r\n  {\r\n    title: 'Advanced Array Patterns',\r\n    examples: [\r\n      {\r\n        title: 'Memoization with Arrays',\r\n        code: `// Memoized array operations\r\nfunction memoizedArrayOperation() {\r\n  const cache = new Map();\r\n  \r\n  return function(array, operation) {\r\n    const key = JSON.stringify(array) + operation.name;\r\n    \r\n    if (cache.has(key)) {\r\n      return cache.get(key);\r\n    }\r\n    \r\n    const result = operation(array);\r\n    cache.set(key, result);\r\n    return result;\r\n  };\r\n}\r\n\r\nconst memoized = memoizedArrayOperation();\r\n\r\nconst expensiveOperation = (arr) => {\r\n  // Simulate expensive computation\r\n  return arr.reduce((sum, num) => sum + Math.pow(num, 2), 0);\r\n};\r\n\r\nconst data = [1, 2, 3, 4, 5];\r\nconsole.log(memoized(data, expensiveOperation)); // Computed\r\nconsole.log(memoized(data, expensiveOperation)); // Cached`\r\n      },\r\n      {\r\n        title: 'Array Decorators',\r\n        code: `// Array method decorators\r\nfunction withLogging(target, propertyKey, descriptor) {\r\n  const originalMethod = descriptor.value;\r\n  \r\n  descriptor.value = function(...args) {\r\n    console.log(\\`Calling \\${propertyKey} with args:\\`, args);\r\n    const result = originalMethod.apply(this, args);\r\n    console.log(\\`Result:\\`, result);\r\n    return result;\r\n  };\r\n  \r\n  return descriptor;\r\n}\r\n\r\nclass ArrayProcessor {\r\n  @withLogging\r\n  static filterEvenNumbers(array) {\r\n    return array.filter(num => num % 2 === 0);\r\n  }\r\n  \r\n  @withLogging\r\n  static doubleNumbers(array) {\r\n    return array.map(num => num * 2);\r\n  }\r\n}\r\n\r\nconst numbers = [1, 2, 3, 4, 5, 6];\r\nArrayProcessor.filterEvenNumbers(numbers);\r\nArrayProcessor.doubleNumbers(numbers);`\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    title: 'Functional Programming Patterns',\r\n    examples: [\r\n      {\r\n        title: 'Point-Free Style',\r\n        code: `// Point-free array operations\r\nconst pipe = (...fns) => x => fns.reduce((v, f) => f(v), x);\r\nconst compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);\r\n\r\n// Utility functions\r\nconst filter = fn => arr => arr.filter(fn);\r\nconst map = fn => arr => arr.map(fn);\r\nconst reduce = fn => initial => arr => arr.reduce(fn, initial);\r\n\r\n// Point-free operations\r\nconst isEven = num => num % 2 === 0;\r\nconst double = num => num * 2;\r\nconst sum = (a, b) => a + b;\r\n\r\nconst processNumbers = pipe(\r\n  filter(isEven),\r\n  map(double),\r\n  reduce(sum)(0)\r\n);\r\n\r\nconst numbers = [1, 2, 3, 4, 5, 6];\r\nconsole.log(processNumbers(numbers)); // 24 (2+4+6 doubled)`\r\n      },\r\n      {\r\n        title: 'Monadic Operations',\r\n        code: `// Maybe monad for safe array operations\r\nclass Maybe {\r\n  constructor(value) {\r\n    this.value = value;\r\n  }\r\n  \r\n  static of(value) {\r\n    return new Maybe(value);\r\n  }\r\n  \r\n  map(fn) {\r\n    return this.value === null || this.value === undefined\r\n      ? Maybe.of(null)\r\n      : Maybe.of(fn(this.value));\r\n  }\r\n  \r\n  flatMap(fn) {\r\n    return this.map(fn).join();\r\n  }\r\n  \r\n  join() {\r\n    return this.value instanceof Maybe ? this.value : this;\r\n  }\r\n}\r\n\r\n// Safe array operations\r\nconst safeArrayOperation = (array, operation) => {\r\n  return Maybe.of(array)\r\n    .map(arr => Array.isArray(arr) ? arr : null)\r\n    .map(operation)\r\n    .map(result => result || []);\r\n};\r\n\r\nconst numbers = [1, 2, 3, 4, 5];\r\nconst result = safeArrayOperation(numbers, arr => arr.filter(n => n > 3));\r\nconsole.log(result.value); // [4, 5]`\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    title: 'Iterator Patterns',\r\n    examples: [\r\n      {\r\n        title: 'Custom Array Iterators',\r\n        code: `// Custom array iterator with filtering\r\nclass FilteredArrayIterator {\r\n  constructor(array, predicate) {\r\n    this.array = array;\r\n    this.predicate = predicate;\r\n    this.index = 0;\r\n  }\r\n\r\n  next() {\r\n    while (this.index < this.array.length) {\r\n      const item = this.array[this.index];\r\n      this.index++;\r\n      \r\n      if (this.predicate(item)) {\r\n        return { value: item, done: false };\r\n      }\r\n    }\r\n    \r\n    return { done: true };\r\n  }\r\n\r\n  [Symbol.iterator]() {\r\n    return this;\r\n  }\r\n}\r\n\r\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\nconst evenIterator = new FilteredArrayIterator(numbers, num => num % 2 === 0);\r\n\r\nfor (const even of evenIterator) {\r\n  console.log(even); // 2, 4, 6, 8, 10\r\n}`\r\n      },\r\n      {\r\n        title: 'Generator-Based Iterators',\r\n        code: `// Generator for array combinations\r\nfunction* arrayCombinations(array, size) {\r\n  if (size === 1) {\r\n    for (const item of array) {\r\n      yield [item];\r\n    }\r\n    return;\r\n  }\r\n  \r\n  for (let i = 0; i <= array.length - size; i++) {\r\n    const first = array[i];\r\n    const remaining = array.slice(i + 1);\r\n    \r\n    for (const combination of arrayCombinations(remaining, size - 1)) {\r\n      yield [first, ...combination];\r\n    }\r\n  }\r\n}\r\n\r\nconst items = ['a', 'b', 'c'];\r\nfor (const combo of arrayCombinations(items, 2)) {\r\n  console.log(combo);\r\n}\r\n// Output: ['a', 'b'], ['a', 'c'], ['b', 'c']`\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    title: 'Optimization Patterns',\r\n    examples: [\r\n      {\r\n        title: 'Lazy Evaluation',\r\n        code: `// Lazy array operations\r\nclass LazyArray {\r\n  constructor(array) {\r\n    this.array = array;\r\n    this.operations = [];\r\n  }\r\n  \r\n  filter(predicate) {\r\n    this.operations.push({ type: 'filter', fn: predicate });\r\n    return this;\r\n  }\r\n  \r\n  map(transform) {\r\n    this.operations.push({ type: 'map', fn: transform });\r\n    return this;\r\n  }\r\n  \r\n  execute() {\r\n    let result = [...this.array];\r\n    \r\n    for (const operation of this.operations) {\r\n      if (operation.type === 'filter') {\r\n        result = result.filter(operation.fn);\r\n      } else if (operation.type === 'map') {\r\n        result = result.map(operation.fn);\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n}\r\n\r\nconst lazyArray = new LazyArray([1, 2, 3, 4, 5, 6])\r\n  .filter(num => num % 2 === 0)\r\n  .map(num => num * 2);\r\n\r\nconsole.log(lazyArray.execute()); // [4, 8, 12]`\r\n      },\r\n      {\r\n        title: 'Memory-Efficient Processing',\r\n        code: `// Stream-like array processing\r\nclass ArrayStream {\r\n  constructor(array) {\r\n    this.array = array;\r\n    this.index = 0;\r\n  }\r\n  \r\n  hasNext() {\r\n    return this.index < this.array.length;\r\n  }\r\n  \r\n  next() {\r\n    return this.array[this.index++];\r\n  }\r\n  \r\n  forEach(consumer) {\r\n    while (this.hasNext()) {\r\n      consumer(this.next());\r\n    }\r\n  }\r\n  \r\n  collect() {\r\n    const result = [];\r\n    this.forEach(item => result.push(item));\r\n    return result;\r\n  }\r\n}\r\n\r\nconst stream = new ArrayStream([1, 2, 3, 4, 5]);\r\nstream.forEach(item => console.log(\\`Processing: \\${item}\\`));`\r\n      }\r\n    ]\r\n  }\r\n];\r\n\r\nexport default advancedContent; "],"names":["title","examples","code"],"sourceRoot":""}