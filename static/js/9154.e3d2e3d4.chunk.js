"use strict";(self.webpackChunkcodebank=self.webpackChunkcodebank||[]).push([[9154],{9154:(n,e,t)=>{t.r(e),t.d(e,{default:()=>i});const i=[{title:"Array Chunking Basics",examples:[{title:"Basic Chunking",code:"// Manual chunking\nfunction chunkArray(array, size) {\n  const chunks = [];\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst chunks = chunkArray(numbers, 3);\nconsole.log(chunks);\n// Output: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]"},{title:"Using Array Methods",code:"// Using reduce for chunking\nfunction chunkWithReduce(array, size) {\n  return array.reduce((chunks, item, index) => {\n    const chunkIndex = Math.floor(index / size);\n    if (!chunks[chunkIndex]) {\n      chunks[chunkIndex] = [];\n    }\n    chunks[chunkIndex].push(item);\n    return chunks;\n  }, []);\n}\n\nconst data = ['a', 'b', 'c', 'd', 'e', 'f'];\nconst result = chunkWithReduce(data, 2);\nconsole.log(result);\n// Output: [['a', 'b'], ['c', 'd'], ['e', 'f']]"}]},{title:"Array Partitioning",examples:[{title:"Basic Partitioning",code:"// Partition array into even and odd numbers\nfunction partition(array, predicate) {\n  return array.reduce((result, item) => {\n    if (predicate(item)) {\n      result[0].push(item);\n    } else {\n      result[1].push(item);\n    }\n    return result;\n  }, [[], []]);\n}\n\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst [evens, odds] = partition(numbers, num => num % 2 === 0);\nconsole.log('Evens:', evens); // [2, 4, 6, 8, 10]\nconsole.log('Odds:', odds);   // [1, 3, 5, 7, 9]"},{title:"Multiple Partitions",code:"// Partition into multiple categories\nfunction multiPartition(array, classifier) {\n  return array.reduce((partitions, item) => {\n    const category = classifier(item);\n    if (!partitions[category]) {\n      partitions[category] = [];\n    }\n    partitions[category].push(item);\n    return partitions;\n  }, {});\n}\n\nconst students = [\n  { name: 'Alice', grade: 'A' },\n  { name: 'Bob', grade: 'B' },\n  { name: 'Charlie', grade: 'A' },\n  { name: 'Diana', grade: 'C' }\n];\n\nconst byGrade = multiPartition(students, student => student.grade);\nconsole.log(byGrade);\n// Output: { A: [...], B: [...], C: [...] }"}]},{title:"Advanced Chunking Patterns",examples:[{title:"Overlapping Chunks",code:"// Create overlapping chunks (sliding window)\nfunction slidingChunks(array, size, step = 1) {\n  const chunks = [];\n  for (let i = 0; i <= array.length - size; i += step) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\nconst data = [1, 2, 3, 4, 5, 6];\nconst sliding = slidingChunks(data, 3, 1);\nconsole.log(sliding);\n// Output: [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]"},{title:"Weighted Chunking",code:"// Chunk based on cumulative weight\nfunction weightedChunk(array, weightFn, maxWeight) {\n  const chunks = [];\n  let currentChunk = [];\n  let currentWeight = 0;\n\n  for (const item of array) {\n    const itemWeight = weightFn(item);\n    \n    if (currentWeight + itemWeight > maxWeight && currentChunk.length > 0) {\n      chunks.push(currentChunk);\n      currentChunk = [item];\n      currentWeight = itemWeight;\n    } else {\n      currentChunk.push(item);\n      currentWeight += itemWeight;\n    }\n  }\n  \n  if (currentChunk.length > 0) {\n    chunks.push(currentChunk);\n  }\n  \n  return chunks;\n}\n\nconst tasks = [\n  { name: 'Task 1', duration: 2 },\n  { name: 'Task 2', duration: 3 },\n  { name: 'Task 3', duration: 1 },\n  { name: 'Task 4', duration: 4 }\n];\n\nconst scheduled = weightedChunk(tasks, task => task.duration, 5);\nconsole.log(scheduled);\n// Output: [[Task 1, Task 2], [Task 3], [Task 4]]"}]},{title:"Performance Considerations",examples:[{title:"Memory Efficient Chunking",code:"// Generator-based chunking for large arrays\nfunction* chunkGenerator(array, size) {\n  for (let i = 0; i < array.length; i += size) {\n    yield array.slice(i, i + size);\n  }\n}\n\n// Usage with large datasets\nconst largeArray = Array.from({ length: 1000000 }, (_, i) => i);\n\nfor (const chunk of chunkGenerator(largeArray, 1000)) {\n  // Process each chunk without loading everything into memory\n  console.log('Processing chunk:', chunk.length);\n}"},{title:"Lazy Evaluation",code:"// Lazy chunking with iterator\nclass LazyChunker {\n  constructor(array, size) {\n    this.array = array;\n    this.size = size;\n    this.index = 0;\n  }\n\n  next() {\n    if (this.index >= this.array.length) {\n      return { done: true };\n    }\n\n    const chunk = this.array.slice(this.index, this.index + this.size);\n    this.index += this.size;\n    \n    return { value: chunk, done: false };\n  }\n\n  [Symbol.iterator]() {\n    return this;\n  }\n}\n\nconst data = [1, 2, 3, 4, 5, 6, 7, 8];\nconst lazyChunker = new LazyChunker(data, 3);\n\nfor (const chunk of lazyChunker) {\n  console.log(chunk);\n}\n// Output: [1, 2, 3], [4, 5, 6], [7, 8]"}]},{title:"Real-World Examples",examples:[{title:"API Request Batching",code:"// Batch API requests to avoid rate limits\nasync function batchApiRequests(items, batchSize = 10) {\n  const batches = [];\n  for (let i = 0; i < items.length; i += batchSize) {\n    batches.push(items.slice(i, i + batchSize));\n  }\n\n  const results = [];\n  for (const batch of batches) {\n    const batchPromises = batch.map(item => \n      fetch(`/api/item/${item.id}`)\n    );\n    \n    const batchResults = await Promise.all(batchPromises);\n    results.push(...batchResults);\n    \n    // Add delay between batches to respect rate limits\n    await new Promise(resolve => setTimeout(resolve, 100));\n  }\n  \n  return results;}"},{title:"Data Processing Pipeline",code:"// Process data in chunks for better performance\nfunction processDataInChunks(data, chunkSize, processor) {\n  const chunks = [];\n  for (let i = 0; i < data.length; i += chunkSize) {\n    chunks.push(data.slice(i, i + chunkSize));\n  }\n\n  return chunks.map((chunk, index) => {\n    console.log(`Processing chunk ${index + 1}/${chunks.length}`);\n    return processor(chunk);\n  });\n}\n\n// Example usage\nconst largeDataset = Array.from({ length: 10000 }, (_, i) => i);\nconst processed = processDataInChunks(\n  largeDataset, \n  1000, \n  chunk => chunk.map(x => x * 2)\n);"},{title:"UI Rendering Optimization",code:"// Render large lists in chunks for smooth UI\nclass VirtualList {\n  constructor(items, chunkSize = 50) {\n    this.items = items;\n    this.chunkSize = chunkSize;\n    this.visibleItems = [];\n    this.currentIndex = 0;\n  }\n\n  renderNextChunk() {\n    const chunk = this.items.slice(\n      this.currentIndex, \n      this.currentIndex + this.chunkSize\n    );\n    \n    this.visibleItems.push(...chunk);\n    this.currentIndex += this.chunkSize;\n    \n    return chunk;\n  }\n\n  hasMore() {\n    return this.currentIndex < this.items.length;\n  }\n}\n\n// Usage in React-like component\nconst virtualList = new VirtualList(Array.from({ length: 1000 }, (_, i) => i));\n\nfunction renderChunk() {\n  if (virtualList.hasMore()) {\n    const chunk = virtualList.renderNextChunk();\n    // Render chunk to DOM\n    console.log('Rendered chunk:', chunk.length, 'items');\n    \n    // Schedule next chunk\n    setTimeout(renderChunk, 16); // ~60fps\n  }\n}"}]}]}}]);
//# sourceMappingURL=9154.e3d2e3d4.chunk.js.map