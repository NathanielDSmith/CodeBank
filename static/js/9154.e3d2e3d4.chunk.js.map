{"version":3,"file":"static/js/9154.e3d2e3d4.chunk.js","mappings":"kIAEA,MA8SA,EA9S0C,CACxC,CACEA,MAAO,wBACPC,SAAU,CACR,CACED,MAAO,iBACPE,KAAK,8WAcP,CACEF,MAAO,sBACPE,KAAK,6dAmBX,CACEF,MAAO,qBACPC,SAAU,CACR,CACED,MAAO,qBACPE,KAAK,gfAiBP,CACEF,MAAO,sBACPE,KAAK,mnBAyBX,CACEF,MAAO,6BACPC,SAAU,CACR,CACED,MAAO,qBACPE,KAAK,wZAcP,CACEF,MAAO,oBACPE,KAAK,k6BAuCX,CACEF,MAAO,6BACPC,SAAU,CACR,CACED,MAAO,4BACPE,KAAK,2cAeP,CACEF,MAAO,kBACPE,KAAK,spBAkCX,CACEF,MAAO,sBACPC,SAAU,CACR,CACED,MAAO,uBACPE,KAAK,koBAsBP,CACEF,MAAO,2BACPE,KAAK,wkBAqBP,CACEF,MAAO,4BACPE,KAAK,q8B","sources":["data/array/chunking.ts"],"sourcesContent":["import { ContentSection } from '../../types';\r\n\r\nconst chunkingContent: ContentSection[] = [\r\n  {\r\n    title: 'Array Chunking Basics',\r\n    examples: [\r\n      {\r\n        title: 'Basic Chunking',\r\n        code: `// Manual chunking\r\nfunction chunkArray(array, size) {\r\n  const chunks = [];\r\n  for (let i = 0; i < array.length; i += size) {\r\n    chunks.push(array.slice(i, i + size));\r\n  }\r\n  return chunks;\r\n}\r\n\r\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\nconst chunks = chunkArray(numbers, 3);\r\nconsole.log(chunks);\r\n// Output: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]`\r\n      },\r\n      {\r\n        title: 'Using Array Methods',\r\n        code: `// Using reduce for chunking\r\nfunction chunkWithReduce(array, size) {\r\n  return array.reduce((chunks, item, index) => {\r\n    const chunkIndex = Math.floor(index / size);\r\n    if (!chunks[chunkIndex]) {\r\n      chunks[chunkIndex] = [];\r\n    }\r\n    chunks[chunkIndex].push(item);\r\n    return chunks;\r\n  }, []);\r\n}\r\n\r\nconst data = ['a', 'b', 'c', 'd', 'e', 'f'];\r\nconst result = chunkWithReduce(data, 2);\r\nconsole.log(result);\r\n// Output: [['a', 'b'], ['c', 'd'], ['e', 'f']]`\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    title: 'Array Partitioning',\r\n    examples: [\r\n      {\r\n        title: 'Basic Partitioning',\r\n        code: `// Partition array into even and odd numbers\r\nfunction partition(array, predicate) {\r\n  return array.reduce((result, item) => {\r\n    if (predicate(item)) {\r\n      result[0].push(item);\r\n    } else {\r\n      result[1].push(item);\r\n    }\r\n    return result;\r\n  }, [[], []]);\r\n}\r\n\r\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\nconst [evens, odds] = partition(numbers, num => num % 2 === 0);\r\nconsole.log('Evens:', evens); // [2, 4, 6, 8, 10]\r\nconsole.log('Odds:', odds);   // [1, 3, 5, 7, 9]`\r\n      },\r\n      {\r\n        title: 'Multiple Partitions',\r\n        code: `// Partition into multiple categories\r\nfunction multiPartition(array, classifier) {\r\n  return array.reduce((partitions, item) => {\r\n    const category = classifier(item);\r\n    if (!partitions[category]) {\r\n      partitions[category] = [];\r\n    }\r\n    partitions[category].push(item);\r\n    return partitions;\r\n  }, {});\r\n}\r\n\r\nconst students = [\r\n  { name: 'Alice', grade: 'A' },\r\n  { name: 'Bob', grade: 'B' },\r\n  { name: 'Charlie', grade: 'A' },\r\n  { name: 'Diana', grade: 'C' }\r\n];\r\n\r\nconst byGrade = multiPartition(students, student => student.grade);\r\nconsole.log(byGrade);\r\n// Output: { A: [...], B: [...], C: [...] }`\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    title: 'Advanced Chunking Patterns',\r\n    examples: [\r\n      {\r\n        title: 'Overlapping Chunks',\r\n        code: `// Create overlapping chunks (sliding window)\r\nfunction slidingChunks(array, size, step = 1) {\r\n  const chunks = [];\r\n  for (let i = 0; i <= array.length - size; i += step) {\r\n    chunks.push(array.slice(i, i + size));\r\n  }\r\n  return chunks;\r\n}\r\n\r\nconst data = [1, 2, 3, 4, 5, 6];\r\nconst sliding = slidingChunks(data, 3, 1);\r\nconsole.log(sliding);\r\n// Output: [[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6]]`\r\n      },\r\n      {\r\n        title: 'Weighted Chunking',\r\n        code: `// Chunk based on cumulative weight\r\nfunction weightedChunk(array, weightFn, maxWeight) {\r\n  const chunks = [];\r\n  let currentChunk = [];\r\n  let currentWeight = 0;\r\n\r\n  for (const item of array) {\r\n    const itemWeight = weightFn(item);\r\n    \r\n    if (currentWeight + itemWeight > maxWeight && currentChunk.length > 0) {\r\n      chunks.push(currentChunk);\r\n      currentChunk = [item];\r\n      currentWeight = itemWeight;\r\n    } else {\r\n      currentChunk.push(item);\r\n      currentWeight += itemWeight;\r\n    }\r\n  }\r\n  \r\n  if (currentChunk.length > 0) {\r\n    chunks.push(currentChunk);\r\n  }\r\n  \r\n  return chunks;\r\n}\r\n\r\nconst tasks = [\r\n  { name: 'Task 1', duration: 2 },\r\n  { name: 'Task 2', duration: 3 },\r\n  { name: 'Task 3', duration: 1 },\r\n  { name: 'Task 4', duration: 4 }\r\n];\r\n\r\nconst scheduled = weightedChunk(tasks, task => task.duration, 5);\r\nconsole.log(scheduled);\r\n// Output: [[Task 1, Task 2], [Task 3], [Task 4]]`\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    title: 'Performance Considerations',\r\n    examples: [\r\n      {\r\n        title: 'Memory Efficient Chunking',\r\n        code: `// Generator-based chunking for large arrays\r\nfunction* chunkGenerator(array, size) {\r\n  for (let i = 0; i < array.length; i += size) {\r\n    yield array.slice(i, i + size);\r\n  }\r\n}\r\n\r\n// Usage with large datasets\r\nconst largeArray = Array.from({ length: 1000000 }, (_, i) => i);\r\n\r\nfor (const chunk of chunkGenerator(largeArray, 1000)) {\r\n  // Process each chunk without loading everything into memory\r\n  console.log('Processing chunk:', chunk.length);\r\n}`\r\n      },\r\n      {\r\n        title: 'Lazy Evaluation',\r\n        code: `// Lazy chunking with iterator\r\nclass LazyChunker {\r\n  constructor(array, size) {\r\n    this.array = array;\r\n    this.size = size;\r\n    this.index = 0;\r\n  }\r\n\r\n  next() {\r\n    if (this.index >= this.array.length) {\r\n      return { done: true };\r\n    }\r\n\r\n    const chunk = this.array.slice(this.index, this.index + this.size);\r\n    this.index += this.size;\r\n    \r\n    return { value: chunk, done: false };\r\n  }\r\n\r\n  [Symbol.iterator]() {\r\n    return this;\r\n  }\r\n}\r\n\r\nconst data = [1, 2, 3, 4, 5, 6, 7, 8];\r\nconst lazyChunker = new LazyChunker(data, 3);\r\n\r\nfor (const chunk of lazyChunker) {\r\n  console.log(chunk);\r\n}\r\n// Output: [1, 2, 3], [4, 5, 6], [7, 8]`\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    title: 'Real-World Examples',\r\n    examples: [\r\n      {\r\n        title: 'API Request Batching',\r\n        code: `// Batch API requests to avoid rate limits\r\nasync function batchApiRequests(items, batchSize = 10) {\r\n  const batches = [];\r\n  for (let i = 0; i < items.length; i += batchSize) {\r\n    batches.push(items.slice(i, i + batchSize));\r\n  }\r\n\r\n  const results = [];\r\n  for (const batch of batches) {\r\n    const batchPromises = batch.map(item => \r\n      fetch(\\`/api/item/\\${item.id}\\`)\r\n    );\r\n    \r\n    const batchResults = await Promise.all(batchPromises);\r\n    results.push(...batchResults);\r\n    \r\n    // Add delay between batches to respect rate limits\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n  }\r\n  \r\n  return results;}`\r\n      },\r\n      {\r\n        title: 'Data Processing Pipeline',\r\n        code: `// Process data in chunks for better performance\r\nfunction processDataInChunks(data, chunkSize, processor) {\r\n  const chunks = [];\r\n  for (let i = 0; i < data.length; i += chunkSize) {\r\n    chunks.push(data.slice(i, i + chunkSize));\r\n  }\r\n\r\n  return chunks.map((chunk, index) => {\r\n    console.log(\\`Processing chunk \\${index + 1}/\\${chunks.length}\\`);\r\n    return processor(chunk);\r\n  });\r\n}\r\n\r\n// Example usage\r\nconst largeDataset = Array.from({ length: 10000 }, (_, i) => i);\r\nconst processed = processDataInChunks(\r\n  largeDataset, \r\n  1000, \r\n  chunk => chunk.map(x => x * 2)\r\n);`\r\n      },\r\n      {\r\n        title: 'UI Rendering Optimization',\r\n        code: `// Render large lists in chunks for smooth UI\r\nclass VirtualList {\r\n  constructor(items, chunkSize = 50) {\r\n    this.items = items;\r\n    this.chunkSize = chunkSize;\r\n    this.visibleItems = [];\r\n    this.currentIndex = 0;\r\n  }\r\n\r\n  renderNextChunk() {\r\n    const chunk = this.items.slice(\r\n      this.currentIndex, \r\n      this.currentIndex + this.chunkSize\r\n    );\r\n    \r\n    this.visibleItems.push(...chunk);\r\n    this.currentIndex += this.chunkSize;\r\n    \r\n    return chunk;\r\n  }\r\n\r\n  hasMore() {\r\n    return this.currentIndex < this.items.length;\r\n  }\r\n}\r\n\r\n// Usage in React-like component\r\nconst virtualList = new VirtualList(Array.from({ length: 1000 }, (_, i) => i));\r\n\r\nfunction renderChunk() {\r\n  if (virtualList.hasMore()) {\r\n    const chunk = virtualList.renderNextChunk();\r\n    // Render chunk to DOM\r\n    console.log('Rendered chunk:', chunk.length, 'items');\r\n    \r\n    // Schedule next chunk\r\n    setTimeout(renderChunk, 16); // ~60fps\r\n  }\r\n}`\r\n      }\r\n    ]\r\n  }\r\n];\r\n\r\nexport default chunkingContent; "],"names":["title","examples","code"],"sourceRoot":""}