"use strict";(self.webpackChunkcodebank=self.webpackChunkcodebank||[]).push([[8958],{8958:(n,e,t)=>{t.r(e),t.d(e,{default:()=>r});const r=[{title:"Context with Timeout",code:'package main\n\nimport (\n    "context"\n    "fmt"\n    "time"\n)\n\nfunc longRunningTask(ctx context.Context) string {\n    select {\n    case <-time.After(5 * time.Second):\n        return "Task completed"\n    case <-ctx.Done():\n        return "Task cancelled: " + ctx.Err().Error()\n    }\n}\n\nfunc main() {\n    // Create context with 3 second timeout\n    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n    defer cancel()\n    \n    result := longRunningTask(ctx)\n    fmt.Println(result)\n}'},{title:"Custom Error Types",code:'package main\n\nimport (\n    "fmt"\n    "time"\n)\n\ntype ValidationError struct {\n    Field string\n    Value interface{}\n    Message string\n}\n\nfunc (e ValidationError) Error() string {\n    return fmt.Sprintf("validation error on %s: %v - %s", e.Field, e.Value, e.Message)\n}\n\ntype AgeError struct {\n    Age int\n    Min int\n    Max int\n}\n\nfunc (e AgeError) Error() string {\n    return fmt.Sprintf("age %d is outside valid range [%d, %d]", e.Age, e.Min, e.Max)\n}\n\nfunc validateAge(age int) error {\n    if age < 0 {\n        return &ValidationError{Field: "age", Value: age, Message: "age cannot be negative"}\n    }\n    if age > 150 {\n        return &AgeError{Age: age, Min: 0, Max: 150}\n    }\n    return nil\n}\n\nfunc main() {\n    ages := []int{25, -5, 200, 30}\n    \n    for _, age := range ages {\n        if err := validateAge(age); err != nil {\n            fmt.Printf("Error: %v\\n", err)\n        } else {\n            fmt.Printf("Age %d is valid\\n", age)\n        }\n    }\n}'},{title:"Reflection",code:'package main\n\nimport (\n    "fmt"\n    "reflect"\n)\n\ntype Person struct {\n    Name string `json:"name" validate:"required"`\n    Age  int    `json:"age" validate:"min:0,max:150"`\n    City string `json:"city"`\n}\n\nfunc inspectStruct(v interface{}) {\n    t := reflect.TypeOf(v)\n    v_val := reflect.ValueOf(v)\n    \n    fmt.Printf("Type: %s\\n", t.Name())\n    fmt.Printf("Kind: %s\\n", t.Kind())\n    fmt.Printf("Num fields: %d\\n\\n", t.NumField())\n    \n    for i := 0; i < t.NumField(); i++ {\n        field := t.Field(i)\n        value := v_val.Field(i)\n        \n        fmt.Printf("Field: %s\\n", field.Name)\n        fmt.Printf("  Type: %s\\n", field.Type)\n        fmt.Printf("  Tag: %s\\n", field.Tag)\n        fmt.Printf("  Value: %v\\n\\n", value.Interface())\n    }\n}\n\nfunc main() {\n    person := Person{\n        Name: "Alice",\n        Age:  30,\n        City: "New York",\n    }\n    \n    inspectStruct(person)\n}'},{title:"Generics (Go 1.18+)",code:'package main\n\nimport "fmt"\n\n// Generic function that works with any comparable type\nfunc findIndex[T comparable](slice []T, item T) int {\n    for i, v := range slice {\n        if v == item {\n            return i\n        }\n    }\n    return -1\n}\n\n// Generic struct\ntype Stack[T any] struct {\n    items []T\n}\n\nfunc NewStack[T any]() *Stack[T] {\n    return &Stack[T]{items: make([]T, 0)}\n}\n\nfunc (s *Stack[T]) Push(item T) {\n    s.items = append(s.items, item)\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n    if len(s.items) == 0 {\n        var zero T\n        return zero, false\n    }\n    \n    item := s.items[len(s.items)-1]\n    s.items = s.items[:len(s.items)-1]\n    return item, true\n}\n\nfunc (s *Stack[T]) Size() int {\n    return len(s.items)\n}\n\nfunc main() {\n    // Using generic function\n    numbers := []int{1, 2, 3, 4, 5}\n    index := findIndex(numbers, 3)\n    fmt.Printf("Index of 3: %d\\n", index)\n    \n    strings := []string{"apple", "banana", "cherry"}\n    strIndex := findIndex(strings, "banana")\n    fmt.Printf("Index of \'banana\': %d\\n", strIndex)\n    \n    // Using generic struct\n    intStack := NewStack[int]()\n    intStack.Push(1)\n    intStack.Push(2)\n    intStack.Push(3)\n    \n    fmt.Printf("Stack size: %d\\n", intStack.Size())\n    \n    if item, ok := intStack.Pop(); ok {\n        fmt.Printf("Popped: %d\\n", item)\n    }\n}'},{title:"Worker Pool Pattern",code:'package main\n\nimport (\n    "fmt"\n    "sync"\n    "time"\n)\n\ntype Job struct {\n    ID       int\n    Data     string\n    Duration time.Duration\n}\n\ntype Result struct {\n    JobID  int\n    Output string\n    Error  error\n}\n\nfunc worker(id int, jobs <-chan Job, results chan<- Result, wg *sync.WaitGroup) {\n    defer wg.Done()\n    \n    for job := range jobs {\n        fmt.Printf("Worker %d processing job %d\\n", id, job.ID)\n        \n        // Simulate work\n        time.Sleep(job.Duration)\n        \n        result := Result{\n            JobID:  job.ID,\n            Output: fmt.Sprintf("Processed: %s", job.Data),\n        }\n        \n        results <- result\n    }\n}\n\nfunc main() {\n    const numWorkers = 3\n    const numJobs = 10\n    \n    jobs := make(chan Job, numJobs)\n    results := make(chan Result, numJobs)\n    \n    var wg sync.WaitGroup\n    \n    // Start workers\n    for i := 1; i <= numWorkers; i++ {\n        wg.Add(1)\n        go worker(i, jobs, results, &wg)\n    }\n    \n    // Send jobs\n    for i := 1; i <= numJobs; i++ {\n        jobs <- Job{\n            ID:       i,\n            Data:     fmt.Sprintf("data-%d", i),\n            Duration: time.Duration(i%3+1) * time.Second,\n        }\n    }\n    close(jobs)\n    \n    // Wait for all workers to finish\n    go func() {\n        wg.Wait()\n        close(results)\n    }()\n    \n    // Collect results\n    for result := range results {\n        fmt.Printf("Job %d completed: %s\\n", result.JobID, result.Output)\n    }\n    \n    fmt.Println("All jobs completed!")\n}'}]}}]);
//# sourceMappingURL=8958.43fe676d.chunk.js.map