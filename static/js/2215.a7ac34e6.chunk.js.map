{"version":3,"file":"static/js/2215.a7ac34e6.chunk.js","mappings":"kIAEA,MA8SA,EA9S6C,CAC3C,CACEA,MAAO,iCACPC,SAAU,CACR,CACED,MAAO,2BACPE,KAAK,u7BAqCP,CACEF,MAAO,sBACPE,KAAK,mlCAoDX,CACEF,MAAO,0BACPC,SAAU,CACR,CACED,MAAO,2BACPE,KAAK,koBAwBP,CACEF,MAAO,4BACPE,KAAK,snCAkDX,CACEF,MAAO,6BACPC,SAAU,CACR,CACED,MAAO,0BACPE,KAAK,k+CAiEP,CACEF,MAAO,0BACPE,KAAK,4zC","sources":["data/array/performance.ts"],"sourcesContent":["import { ContentSection } from '../../types';\r\n\r\nconst performanceContent: ContentSection[] = [\r\n  {\r\n    title: 'Array Performance Optimization',\r\n    examples: [\r\n      {\r\n        title: 'Time Complexity Analysis',\r\n        code: `// Understanding array method performance\r\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n\r\n// O(n) - Linear time\r\nconst linearSearch = (arr, target) => {\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (arr[i] === target) return i;\r\n  }\r\n  return -1;\r\n};\r\n\r\n// O(log n) - Binary search (requires sorted array)\r\nconst binarySearch = (arr, target) => {\r\n  let left = 0;\r\n  let right = arr.length - 1;\r\n  \r\n  while (left <= right) {\r\n    const mid = Math.floor((left + right) / 2);\r\n    if (arr[mid] === target) return mid;\r\n    if (arr[mid] < target) left = mid + 1;\r\n    else right = mid - 1;\r\n  }\r\n  return -1;\r\n};\r\n\r\n// Performance comparison\r\nconst largeArray = Array.from({ length: 1000000 }, (_, i) => i);\r\nconst target = 999999;\r\n\r\nconsole.time('Linear Search');\r\nlinearSearch(largeArray, target);\r\nconsole.timeEnd('Linear Search');\r\n\r\nconsole.time('Binary Search');\r\nbinarySearch(largeArray, target);\r\nconsole.timeEnd('Binary Search');`\r\n      },\r\n      {\r\n        title: 'Memory Optimization',\r\n        code: `// Memory-efficient array operations\r\nclass MemoryEfficientArray {\r\n  constructor() {\r\n    this.data = [];\r\n    this.deletedIndices = new Set();\r\n  }\r\n  \r\n  add(item) {\r\n    this.data.push(item);\r\n  }\r\n  \r\n  delete(index) {\r\n    // Mark as deleted instead of removing\r\n    this.deletedIndices.add(index);\r\n  }\r\n  \r\n  get(index) {\r\n    if (this.deletedIndices.has(index)) {\r\n      return undefined;\r\n    }\r\n    return this.data[index];\r\n  }\r\n  \r\n  compact() {\r\n    // Only compact when necessary\r\n    if (this.deletedIndices.size > this.data.length / 2) {\r\n      this.data = this.data.filter((_, index) => !this.deletedIndices.has(index));\r\n      this.deletedIndices.clear();\r\n    }\r\n  }\r\n  \r\n  toArray() {\r\n    return this.data.filter((_, index) => !this.deletedIndices.has(index));\r\n  }\r\n}\r\n\r\nconst efficientArray = new MemoryEfficientArray();\r\nfor (let i = 0; i < 1000; i++) {\r\n  efficientArray.add(i);\r\n}\r\n\r\n// Delete many items\r\nfor (let i = 0; i < 500; i++) {\r\n  efficientArray.delete(i);\r\n}\r\n\r\n// Compact only when needed\r\nefficientArray.compact();\r\nconsole.log(efficientArray.toArray().length);`\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    title: 'Optimization Techniques',\r\n    examples: [\r\n      {\r\n        title: 'Avoiding Common Pitfalls',\r\n        code: `// ❌ Bad: Multiple array iterations\r\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n\r\n// Bad approach\r\nconst badApproach = (arr) => {\r\n  const evens = arr.filter(num => num % 2 === 0);\r\n  const doubled = evens.map(num => num * 2);\r\n  const sum = doubled.reduce((acc, num) => acc + num, 0);\r\n  return sum;\r\n};\r\n\r\n// ✅ Good: Single iteration\r\nconst goodApproach = (arr) => {\r\n  return arr.reduce((sum, num) => {\r\n    if (num % 2 === 0) {\r\n      return sum + (num * 2);\r\n    }\r\n    return sum;\r\n  }, 0);\r\n};\r\n\r\nconsole.log(badApproach(numbers)); // 60\r\nconsole.log(goodApproach(numbers)); // 60 (same result, better performance)`\r\n      },\r\n      {\r\n        title: 'Efficient Data Structures',\r\n        code: `// Using Set for fast lookups\r\nclass OptimizedArrayProcessor {\r\n  constructor() {\r\n    this.uniqueItems = new Set();\r\n    this.itemCounts = new Map();\r\n  }\r\n  \r\n  addItem(item) {\r\n    this.uniqueItems.add(item);\r\n    this.itemCounts.set(item, (this.itemCounts.get(item) || 0) + 1);\r\n  }\r\n  \r\n  hasItem(item) {\r\n    return this.uniqueItems.has(item); // O(1) lookup\r\n  }\r\n  \r\n  getItemCount(item) {\r\n    return this.itemCounts.get(item) || 0;\r\n  }\r\n  \r\n  getUniqueItems() {\r\n    return Array.from(this.uniqueItems);\r\n  }\r\n  \r\n  getMostFrequent() {\r\n    let maxCount = 0;\r\n    let mostFrequent = null;\r\n    \r\n    for (const [item, count] of this.itemCounts) {\r\n      if (count > maxCount) {\r\n        maxCount = count;\r\n        mostFrequent = item;\r\n      }\r\n    }\r\n    \r\n    return mostFrequent;\r\n  }\r\n}\r\n\r\nconst processor = new OptimizedArrayProcessor();\r\nconst items = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple'];\r\n\r\nitems.forEach(item => processor.addItem(item));\r\n\r\nconsole.log(processor.hasItem('apple')); // true\r\nconsole.log(processor.getItemCount('apple')); // 3\r\nconsole.log(processor.getMostFrequent()); // 'apple'`\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    title: 'Benchmarking and Profiling',\r\n    examples: [\r\n      {\r\n        title: 'Performance Measurement',\r\n        code: `// Performance benchmarking utility\r\nclass ArrayBenchmark {\r\n  static measure(name, fn, iterations = 1000) {\r\n    const start = performance.now();\r\n    \r\n    for (let i = 0; i < iterations; i++) {\r\n      fn();\r\n    }\r\n    \r\n    const end = performance.now();\r\n    const average = (end - start) / iterations;\r\n    \r\n    console.log(\\`\\${name}: \\${average.toFixed(4)}ms average\\`);\r\n    return average;\r\n  }\r\n  \r\n  static compare(functions) {\r\n    const results = [];\r\n    \r\n    for (const [name, fn] of Object.entries(functions)) {\r\n      const time = this.measure(name, fn);\r\n      results.push({ name, time });\r\n    }\r\n    \r\n    results.sort((a, b) => a.time - b.time);\r\n    \r\n    console.log('\\\\nPerformance Ranking:');\r\n    results.forEach((result, index) => {\r\n      console.log(\\`\\${index + 1}. \\${result.name}: \\${result.time.toFixed(4)}ms\\`);\r\n    });\r\n    \r\n    return results;\r\n  }\r\n}\r\n\r\n// Example benchmarks\r\nconst testArray = Array.from({ length: 10000 }, (_, i) => i);\r\n\r\nconst functions = {\r\n  'forEach': () => {\r\n    let sum = 0;\r\n    testArray.forEach(num => sum += num);\r\n    return sum;\r\n  },\r\n  'for...of': () => {\r\n    let sum = 0;\r\n    for (const num of testArray) {\r\n      sum += num;\r\n    }\r\n    return sum;\r\n  },\r\n  'for loop': () => {\r\n    let sum = 0;\r\n    for (let i = 0; i < testArray.length; i++) {\r\n      sum += testArray[i];\r\n    }\r\n    return sum;\r\n  },\r\n  'reduce': () => {\r\n    return testArray.reduce((sum, num) => sum + num, 0);\r\n  }\r\n};\r\n\r\nArrayBenchmark.compare(functions);`\r\n      },\r\n      {\r\n        title: 'Memory Usage Monitoring',\r\n        code: `// Memory usage monitoring\r\nclass MemoryMonitor {\r\n  static getMemoryUsage() {\r\n    if (performance.memory) {\r\n      return {\r\n        used: performance.memory.usedJSHeapSize,\r\n        total: performance.memory.totalJSHeapSize,\r\n        limit: performance.memory.jsHeapSizeLimit\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n  \r\n  static logMemoryUsage(label = '') {\r\n    const usage = this.getMemoryUsage();\r\n    if (usage) {\r\n      console.log(\\`\\${label} Memory Usage:\\`, {\r\n        used: \\`\\${(usage.used / 1024 / 1024).toFixed(2)} MB\\`,\r\n        total: \\`\\${(usage.total / 1024 / 1024).toFixed(2)} MB\\`,\r\n        limit: \\`\\${(usage.limit / 1024 / 1024).toFixed(2)} MB\\`\r\n      });\r\n    }\r\n  }\r\n  \r\n  static measureMemoryImpact(fn) {\r\n    const before = this.getMemoryUsage();\r\n    const result = fn();\r\n    const after = this.getMemoryUsage();\r\n    \r\n    if (before && after) {\r\n      const difference = after.used - before.used;\r\n      console.log(\\`Memory impact: \\${(difference / 1024).toFixed(2)} KB\\`);\r\n    }\r\n    \r\n    return result;\r\n  }\r\n}\r\n\r\n// Example usage\r\nMemoryMonitor.logMemoryUsage('Before operation');\r\n\r\nconst largeArray = Array.from({ length: 100000 }, (_, i) => i);\r\nMemoryMonitor.measureMemoryImpact(() => {\r\n  return largeArray.map(x => x * 2).filter(x => x % 2 === 0);\r\n});\r\n\r\nMemoryMonitor.logMemoryUsage('After operation');`\r\n      }\r\n    ]\r\n  }\r\n];\r\n\r\nexport default performanceContent; "],"names":["title","examples","code"],"sourceRoot":""}