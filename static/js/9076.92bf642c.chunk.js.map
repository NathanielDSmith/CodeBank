{"version":3,"file":"static/js/9076.92bf642c.chunk.js","mappings":"kIAEA,MA4UA,EA5U+C,CAC7C,CACEA,MAAO,uBACPC,SAAU,CACR,CACED,MAAO,eACPE,KAAK,kbAaP,CACEF,MAAO,wBACPE,KAAK,wpBA6BX,CACEF,MAAO,oBACPC,SAAU,CACR,CACED,MAAO,yBACPE,KAAK,6zBA8BP,CACEF,MAAO,iBACPE,KAAK,20CAoDX,CACEF,MAAO,6BACPC,SAAU,CACR,CACED,MAAO,sBACPE,KAAK,olBAoBP,CACEF,MAAO,oBACPE,KAAK,88BA8CX,CACEF,MAAO,yBACPC,SAAU,CACR,CACED,MAAO,sBACPE,KAAK,m9CAkEP,CACEF,MAAO,oBACPE,KAAK,unC","sources":["data/array/best-practices.ts"],"sourcesContent":["import { ContentSection } from '../../types';\r\n\r\nconst bestPracticesContent: ContentSection[] = [\r\n  {\r\n    title: 'Array Best Practices',\r\n    examples: [\r\n      {\r\n        title: 'Immutability',\r\n        code: `// ❌ Bad: Mutating original array\r\nconst numbers = [1, 2, 3, 4, 5];\r\nnumbers.push(6); // Mutates original array\r\n\r\n// ✅ Good: Creating new array\r\nconst numbers = [1, 2, 3, 4, 5];\r\nconst newNumbers = [...numbers, 6]; // New array\r\n\r\n// ✅ Good: Using functional methods\r\nconst doubled = numbers.map(num => num * 2);\r\nconst filtered = numbers.filter(num => num > 3);\r\nconst sorted = [...numbers].sort((a, b) => a - b);`\r\n      },\r\n      {\r\n        title: 'Defensive Programming',\r\n        code: `// Always check if array exists and has items\r\nfunction processArray(array) {\r\n  // ✅ Good: Defensive checks\r\n  if (!Array.isArray(array)) {\r\n    throw new Error('Input must be an array');\r\n  }\r\n  \r\n  if (array.length === 0) {\r\n    return [];\r\n  }\r\n  \r\n  return array.map(item => item * 2);\r\n}\r\n\r\n// ✅ Good: Safe array access\r\nconst getItemSafely = (array, index) => {\r\n  if (!Array.isArray(array) || index < 0 || index >= array.length) {\r\n    return undefined;\r\n  }\r\n  return array[index];\r\n};\r\n\r\n// ✅ Good: Default values\r\nconst processWithDefaults = (array = []) => {\r\n  return array.filter(item => item !== null && item !== undefined);\r\n};`\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    title: 'Code Organization',\r\n    examples: [\r\n      {\r\n        title: 'Separation of Concerns',\r\n        code: `// ✅ Good: Separate data transformation logic\r\nclass ArrayProcessor {\r\n  static filterByType(array, type) {\r\n    return array.filter(item => typeof item === type);\r\n  }\r\n  \r\n  static transformNumbers(array, operation) {\r\n    return array\r\n      .filter(item => typeof item === 'number')\r\n      .map(operation);\r\n  }\r\n  \r\n  static groupBy(array, keyFn) {\r\n    return array.reduce((groups, item) => {\r\n      const key = keyFn(item);\r\n      if (!groups[key]) {\r\n        groups[key] = [];\r\n      }\r\n      groups[key].push(item);\r\n      return groups;\r\n    }, {});\r\n  }\r\n}\r\n\r\n// Usage\r\nconst data = [1, 'hello', 2, 'world', 3];\r\nconst numbers = ArrayProcessor.filterByType(data, 'number');\r\nconst doubled = ArrayProcessor.transformNumbers(data, x => x * 2);\r\nconst grouped = ArrayProcessor.groupBy(data, item => typeof item);`\r\n      },\r\n      {\r\n        title: 'Error Handling',\r\n        code: `// ✅ Good: Proper error handling\r\nclass SafeArrayOperations {\r\n  static tryMap(array, mapper) {\r\n    try {\r\n      if (!Array.isArray(array)) {\r\n        throw new Error('Input must be an array');\r\n      }\r\n      \r\n      return array.map((item, index) => {\r\n        try {\r\n          return mapper(item, index);\r\n        } catch (error) {\r\n          console.warn(\\`Error processing item at index \\${index}:\\`, error);\r\n          return null;\r\n        }\r\n      }).filter(item => item !== null);\r\n    } catch (error) {\r\n      console.error('Array operation failed:', error);\r\n      return [];\r\n    }\r\n  }\r\n  \r\n  static validateArray(array, validator) {\r\n    if (!Array.isArray(array)) {\r\n      return { isValid: false, error: 'Not an array' };\r\n    }\r\n    \r\n    const errors = [];\r\n    array.forEach((item, index) => {\r\n      try {\r\n        if (!validator(item)) {\r\n          errors.push(\\`Invalid item at index \\${index}\\`);\r\n        }\r\n      } catch (error) {\r\n        errors.push(\\`Validation error at index \\${index}: \\${error.message}\\`);\r\n      }\r\n    });\r\n    \r\n    return {\r\n      isValid: errors.length === 0,\r\n      errors\r\n    };\r\n  }\r\n}\r\n\r\n// Usage\r\nconst numbers = [1, 2, 'invalid', 4, 5];\r\nconst result = SafeArrayOperations.tryMap(numbers, x => x * 2);\r\nconst validation = SafeArrayOperations.validateArray(numbers, x => typeof x === 'number');`\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    title: 'Performance Best Practices',\r\n    examples: [\r\n      {\r\n        title: 'Efficient Iteration',\r\n        code: `// ✅ Good: Choose the right iteration method\r\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n\r\n// For simple iteration\r\nfor (let i = 0; i < numbers.length; i++) {\r\n  console.log(numbers[i]);\r\n}\r\n\r\n// For functional operations\r\nconst doubled = numbers.map(num => num * 2);\r\nconst evens = numbers.filter(num => num % 2 === 0);\r\n\r\n// For early termination\r\nconst findFirstEven = numbers.find(num => num % 2 === 0);\r\nconst hasEven = numbers.some(num => num % 2 === 0);\r\nconst allEven = numbers.every(num => num % 2 === 0);\r\n\r\n// For side effects\r\nnumbers.forEach(num => console.log(num));`\r\n      },\r\n      {\r\n        title: 'Memory Management',\r\n        code: `// ✅ Good: Avoid memory leaks\r\nclass MemoryEfficientProcessor {\r\n  constructor() {\r\n    this.cache = new Map();\r\n    this.maxCacheSize = 1000;\r\n  }\r\n  \r\n  processArray(array, processor) {\r\n    const key = JSON.stringify(array);\r\n    \r\n    if (this.cache.has(key)) {\r\n      return this.cache.get(key);\r\n    }\r\n    \r\n    const result = processor(array);\r\n    \r\n    // Prevent cache from growing too large\r\n    if (this.cache.size >= this.maxCacheSize) {\r\n      const firstKey = this.cache.keys().next().value;\r\n      this.cache.delete(firstKey);\r\n    }\r\n    \r\n    this.cache.set(key, result);\r\n    return result;\r\n  }\r\n  \r\n  clearCache() {\r\n    this.cache.clear();\r\n  }\r\n}\r\n\r\n// ✅ Good: Use WeakMap for object keys\r\nconst objectCache = new WeakMap();\r\n\r\nfunction cacheObjectResult(obj, processor) {\r\n  if (objectCache.has(obj)) {\r\n    return objectCache.get(obj);\r\n  }\r\n  \r\n  const result = processor(obj);\r\n  objectCache.set(obj, result);\r\n  return result;\r\n}`\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    title: 'Testing Best Practices',\r\n    examples: [\r\n      {\r\n        title: 'Unit Testing Arrays',\r\n        code: `// ✅ Good: Comprehensive array testing\r\nclass ArrayTestUtils {\r\n  static testArrayOperation(operation, testCases) {\r\n    const results = [];\r\n    \r\n    testCases.forEach(({ input, expected, description }) => {\r\n      try {\r\n        const result = operation(input);\r\n        const passed = JSON.stringify(result) === JSON.stringify(expected);\r\n        \r\n        results.push({\r\n          description,\r\n          passed,\r\n          input,\r\n          expected,\r\n          actual: result\r\n        });\r\n      } catch (error) {\r\n        results.push({\r\n          description,\r\n          passed: false,\r\n          input,\r\n          expected,\r\n          error: error.message\r\n        });\r\n      }\r\n    });\r\n    \r\n    return results;\r\n  }\r\n  \r\n  static generateTestData(size = 100) {\r\n    return Array.from({ length: size }, (_, i) => ({\r\n      id: i,\r\n      value: Math.random() * 100,\r\n      category: ['A', 'B', 'C'][i % 3]\r\n    }));\r\n  }\r\n}\r\n\r\n// Example usage\r\nconst testCases = [\r\n  {\r\n    input: [1, 2, 3, 4, 5],\r\n    expected: [2, 4, 6, 8, 10],\r\n    description: 'Double all numbers'\r\n  },\r\n  {\r\n    input: [],\r\n    expected: [],\r\n    description: 'Empty array'\r\n  },\r\n  {\r\n    input: [1, 'invalid', 3],\r\n    expected: [2, 6],\r\n    description: 'Mixed types'\r\n  }\r\n];\r\n\r\nconst doubleNumbers = arr => arr\r\n  .filter(x => typeof x === 'number')\r\n  .map(x => x * 2);\r\n\r\nconst results = ArrayTestUtils.testArrayOperation(doubleNumbers, testCases);\r\nconsole.log('Test Results:', results);`\r\n      },\r\n      {\r\n        title: 'Edge Case Testing',\r\n        code: `// ✅ Good: Test edge cases\r\nconst edgeCaseTests = [\r\n  // Null and undefined\r\n  { input: null, expected: [], description: 'Null input' },\r\n  { input: undefined, expected: [], description: 'Undefined input' },\r\n  \r\n  // Empty arrays\r\n  { input: [], expected: [], description: 'Empty array' },\r\n  \r\n  // Single element\r\n  { input: [1], expected: [2], description: 'Single element' },\r\n  \r\n  // Large arrays\r\n  { \r\n    input: Array.from({ length: 10000 }, (_, i) => i),\r\n    expected: Array.from({ length: 10000 }, (_, i) => i * 2),\r\n    description: 'Large array'\r\n  },\r\n  \r\n  // Nested arrays\r\n  { \r\n    input: [[1, 2], [3, 4], [5, 6]],\r\n    expected: [[2, 4], [6, 8], [10, 12]],\r\n    description: 'Nested arrays'\r\n  }\r\n];\r\n\r\n// Test function that handles edge cases\r\nconst robustArrayProcessor = (array) => {\r\n  if (!Array.isArray(array)) {\r\n    return [];\r\n  }\r\n  \r\n  return array.map(item => {\r\n    if (Array.isArray(item)) {\r\n      return item.map(x => x * 2);\r\n    }\r\n    return typeof item === 'number' ? item * 2 : item;\r\n  });\r\n};\r\n\r\nconst edgeResults = ArrayTestUtils.testArrayOperation(robustArrayProcessor, edgeCaseTests);`\r\n      }\r\n    ]\r\n  }\r\n];\r\n\r\nexport default bestPracticesContent; "],"names":["title","examples","code"],"sourceRoot":""}