"use strict";(self.webpackChunkcodebank=self.webpackChunkcodebank||[]).push([[9076],{9076:(n,e,r)=>{r.r(e),r.d(e,{default:()=>t});const t=[{title:"Array Best Practices",examples:[{title:"Immutability",code:"// \u274c Bad: Mutating original array\nconst numbers = [1, 2, 3, 4, 5];\nnumbers.push(6); // Mutates original array\n\n// \u2705 Good: Creating new array\nconst numbers = [1, 2, 3, 4, 5];\nconst newNumbers = [...numbers, 6]; // New array\n\n// \u2705 Good: Using functional methods\nconst doubled = numbers.map(num => num * 2);\nconst filtered = numbers.filter(num => num > 3);\nconst sorted = [...numbers].sort((a, b) => a - b);"},{title:"Defensive Programming",code:"// Always check if array exists and has items\nfunction processArray(array) {\n  // \u2705 Good: Defensive checks\n  if (!Array.isArray(array)) {\n    throw new Error('Input must be an array');\n  }\n  \n  if (array.length === 0) {\n    return [];\n  }\n  \n  return array.map(item => item * 2);\n}\n\n// \u2705 Good: Safe array access\nconst getItemSafely = (array, index) => {\n  if (!Array.isArray(array) || index < 0 || index >= array.length) {\n    return undefined;\n  }\n  return array[index];\n};\n\n// \u2705 Good: Default values\nconst processWithDefaults = (array = []) => {\n  return array.filter(item => item !== null && item !== undefined);\n};"}]},{title:"Code Organization",examples:[{title:"Separation of Concerns",code:"// \u2705 Good: Separate data transformation logic\nclass ArrayProcessor {\n  static filterByType(array, type) {\n    return array.filter(item => typeof item === type);\n  }\n  \n  static transformNumbers(array, operation) {\n    return array\n      .filter(item => typeof item === 'number')\n      .map(operation);\n  }\n  \n  static groupBy(array, keyFn) {\n    return array.reduce((groups, item) => {\n      const key = keyFn(item);\n      if (!groups[key]) {\n        groups[key] = [];\n      }\n      groups[key].push(item);\n      return groups;\n    }, {});\n  }\n}\n\n// Usage\nconst data = [1, 'hello', 2, 'world', 3];\nconst numbers = ArrayProcessor.filterByType(data, 'number');\nconst doubled = ArrayProcessor.transformNumbers(data, x => x * 2);\nconst grouped = ArrayProcessor.groupBy(data, item => typeof item);"},{title:"Error Handling",code:"// \u2705 Good: Proper error handling\nclass SafeArrayOperations {\n  static tryMap(array, mapper) {\n    try {\n      if (!Array.isArray(array)) {\n        throw new Error('Input must be an array');\n      }\n      \n      return array.map((item, index) => {\n        try {\n          return mapper(item, index);\n        } catch (error) {\n          console.warn(`Error processing item at index ${index}:`, error);\n          return null;\n        }\n      }).filter(item => item !== null);\n    } catch (error) {\n      console.error('Array operation failed:', error);\n      return [];\n    }\n  }\n  \n  static validateArray(array, validator) {\n    if (!Array.isArray(array)) {\n      return { isValid: false, error: 'Not an array' };\n    }\n    \n    const errors = [];\n    array.forEach((item, index) => {\n      try {\n        if (!validator(item)) {\n          errors.push(`Invalid item at index ${index}`);\n        }\n      } catch (error) {\n        errors.push(`Validation error at index ${index}: ${error.message}`);\n      }\n    });\n    \n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n}\n\n// Usage\nconst numbers = [1, 2, 'invalid', 4, 5];\nconst result = SafeArrayOperations.tryMap(numbers, x => x * 2);\nconst validation = SafeArrayOperations.validateArray(numbers, x => typeof x === 'number');"}]},{title:"Performance Best Practices",examples:[{title:"Efficient Iteration",code:"// \u2705 Good: Choose the right iteration method\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// For simple iteration\nfor (let i = 0; i < numbers.length; i++) {\n  console.log(numbers[i]);\n}\n\n// For functional operations\nconst doubled = numbers.map(num => num * 2);\nconst evens = numbers.filter(num => num % 2 === 0);\n\n// For early termination\nconst findFirstEven = numbers.find(num => num % 2 === 0);\nconst hasEven = numbers.some(num => num % 2 === 0);\nconst allEven = numbers.every(num => num % 2 === 0);\n\n// For side effects\nnumbers.forEach(num => console.log(num));"},{title:"Memory Management",code:"// \u2705 Good: Avoid memory leaks\nclass MemoryEfficientProcessor {\n  constructor() {\n    this.cache = new Map();\n    this.maxCacheSize = 1000;\n  }\n  \n  processArray(array, processor) {\n    const key = JSON.stringify(array);\n    \n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    }\n    \n    const result = processor(array);\n    \n    // Prevent cache from growing too large\n    if (this.cache.size >= this.maxCacheSize) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n    \n    this.cache.set(key, result);\n    return result;\n  }\n  \n  clearCache() {\n    this.cache.clear();\n  }\n}\n\n// \u2705 Good: Use WeakMap for object keys\nconst objectCache = new WeakMap();\n\nfunction cacheObjectResult(obj, processor) {\n  if (objectCache.has(obj)) {\n    return objectCache.get(obj);\n  }\n  \n  const result = processor(obj);\n  objectCache.set(obj, result);\n  return result;\n}"}]},{title:"Testing Best Practices",examples:[{title:"Unit Testing Arrays",code:"// \u2705 Good: Comprehensive array testing\nclass ArrayTestUtils {\n  static testArrayOperation(operation, testCases) {\n    const results = [];\n    \n    testCases.forEach(({ input, expected, description }) => {\n      try {\n        const result = operation(input);\n        const passed = JSON.stringify(result) === JSON.stringify(expected);\n        \n        results.push({\n          description,\n          passed,\n          input,\n          expected,\n          actual: result\n        });\n      } catch (error) {\n        results.push({\n          description,\n          passed: false,\n          input,\n          expected,\n          error: error.message\n        });\n      }\n    });\n    \n    return results;\n  }\n  \n  static generateTestData(size = 100) {\n    return Array.from({ length: size }, (_, i) => ({\n      id: i,\n      value: Math.random() * 100,\n      category: ['A', 'B', 'C'][i % 3]\n    }));\n  }\n}\n\n// Example usage\nconst testCases = [\n  {\n    input: [1, 2, 3, 4, 5],\n    expected: [2, 4, 6, 8, 10],\n    description: 'Double all numbers'\n  },\n  {\n    input: [],\n    expected: [],\n    description: 'Empty array'\n  },\n  {\n    input: [1, 'invalid', 3],\n    expected: [2, 6],\n    description: 'Mixed types'\n  }\n];\n\nconst doubleNumbers = arr => arr\n  .filter(x => typeof x === 'number')\n  .map(x => x * 2);\n\nconst results = ArrayTestUtils.testArrayOperation(doubleNumbers, testCases);\nconsole.log('Test Results:', results);"},{title:"Edge Case Testing",code:"// \u2705 Good: Test edge cases\nconst edgeCaseTests = [\n  // Null and undefined\n  { input: null, expected: [], description: 'Null input' },\n  { input: undefined, expected: [], description: 'Undefined input' },\n  \n  // Empty arrays\n  { input: [], expected: [], description: 'Empty array' },\n  \n  // Single element\n  { input: [1], expected: [2], description: 'Single element' },\n  \n  // Large arrays\n  { \n    input: Array.from({ length: 10000 }, (_, i) => i),\n    expected: Array.from({ length: 10000 }, (_, i) => i * 2),\n    description: 'Large array'\n  },\n  \n  // Nested arrays\n  { \n    input: [[1, 2], [3, 4], [5, 6]],\n    expected: [[2, 4], [6, 8], [10, 12]],\n    description: 'Nested arrays'\n  }\n];\n\n// Test function that handles edge cases\nconst robustArrayProcessor = (array) => {\n  if (!Array.isArray(array)) {\n    return [];\n  }\n  \n  return array.map(item => {\n    if (Array.isArray(item)) {\n      return item.map(x => x * 2);\n    }\n    return typeof item === 'number' ? item * 2 : item;\n  });\n};\n\nconst edgeResults = ArrayTestUtils.testArrayOperation(robustArrayProcessor, edgeCaseTests);"}]}]}}]);
//# sourceMappingURL=9076.92bf642c.chunk.js.map