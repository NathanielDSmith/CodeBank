"use strict";(self.webpackChunkcodebank=self.webpackChunkcodebank||[]).push([[2215],{2215:(n,e,t)=>{t.r(e),t.d(e,{default:()=>r});const r=[{title:"Array Performance Optimization",examples:[{title:"Time Complexity Analysis",code:"// Understanding array method performance\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// O(n) - Linear time\nconst linearSearch = (arr, target) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === target) return i;\n  }\n  return -1;\n};\n\n// O(log n) - Binary search (requires sorted array)\nconst binarySearch = (arr, target) => {\n  let left = 0;\n  let right = arr.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  return -1;\n};\n\n// Performance comparison\nconst largeArray = Array.from({ length: 1000000 }, (_, i) => i);\nconst target = 999999;\n\nconsole.time('Linear Search');\nlinearSearch(largeArray, target);\nconsole.timeEnd('Linear Search');\n\nconsole.time('Binary Search');\nbinarySearch(largeArray, target);\nconsole.timeEnd('Binary Search');"},{title:"Memory Optimization",code:"// Memory-efficient array operations\nclass MemoryEfficientArray {\n  constructor() {\n    this.data = [];\n    this.deletedIndices = new Set();\n  }\n  \n  add(item) {\n    this.data.push(item);\n  }\n  \n  delete(index) {\n    // Mark as deleted instead of removing\n    this.deletedIndices.add(index);\n  }\n  \n  get(index) {\n    if (this.deletedIndices.has(index)) {\n      return undefined;\n    }\n    return this.data[index];\n  }\n  \n  compact() {\n    // Only compact when necessary\n    if (this.deletedIndices.size > this.data.length / 2) {\n      this.data = this.data.filter((_, index) => !this.deletedIndices.has(index));\n      this.deletedIndices.clear();\n    }\n  }\n  \n  toArray() {\n    return this.data.filter((_, index) => !this.deletedIndices.has(index));\n  }\n}\n\nconst efficientArray = new MemoryEfficientArray();\nfor (let i = 0; i < 1000; i++) {\n  efficientArray.add(i);\n}\n\n// Delete many items\nfor (let i = 0; i < 500; i++) {\n  efficientArray.delete(i);\n}\n\n// Compact only when needed\nefficientArray.compact();\nconsole.log(efficientArray.toArray().length);"}]},{title:"Optimization Techniques",examples:[{title:"Avoiding Common Pitfalls",code:"// \u274c Bad: Multiple array iterations\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// Bad approach\nconst badApproach = (arr) => {\n  const evens = arr.filter(num => num % 2 === 0);\n  const doubled = evens.map(num => num * 2);\n  const sum = doubled.reduce((acc, num) => acc + num, 0);\n  return sum;\n};\n\n// \u2705 Good: Single iteration\nconst goodApproach = (arr) => {\n  return arr.reduce((sum, num) => {\n    if (num % 2 === 0) {\n      return sum + (num * 2);\n    }\n    return sum;\n  }, 0);\n};\n\nconsole.log(badApproach(numbers)); // 60\nconsole.log(goodApproach(numbers)); // 60 (same result, better performance)"},{title:"Efficient Data Structures",code:"// Using Set for fast lookups\nclass OptimizedArrayProcessor {\n  constructor() {\n    this.uniqueItems = new Set();\n    this.itemCounts = new Map();\n  }\n  \n  addItem(item) {\n    this.uniqueItems.add(item);\n    this.itemCounts.set(item, (this.itemCounts.get(item) || 0) + 1);\n  }\n  \n  hasItem(item) {\n    return this.uniqueItems.has(item); // O(1) lookup\n  }\n  \n  getItemCount(item) {\n    return this.itemCounts.get(item) || 0;\n  }\n  \n  getUniqueItems() {\n    return Array.from(this.uniqueItems);\n  }\n  \n  getMostFrequent() {\n    let maxCount = 0;\n    let mostFrequent = null;\n    \n    for (const [item, count] of this.itemCounts) {\n      if (count > maxCount) {\n        maxCount = count;\n        mostFrequent = item;\n      }\n    }\n    \n    return mostFrequent;\n  }\n}\n\nconst processor = new OptimizedArrayProcessor();\nconst items = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple'];\n\nitems.forEach(item => processor.addItem(item));\n\nconsole.log(processor.hasItem('apple')); // true\nconsole.log(processor.getItemCount('apple')); // 3\nconsole.log(processor.getMostFrequent()); // 'apple'"}]},{title:"Benchmarking and Profiling",examples:[{title:"Performance Measurement",code:"// Performance benchmarking utility\nclass ArrayBenchmark {\n  static measure(name, fn, iterations = 1000) {\n    const start = performance.now();\n    \n    for (let i = 0; i < iterations; i++) {\n      fn();\n    }\n    \n    const end = performance.now();\n    const average = (end - start) / iterations;\n    \n    console.log(`${name}: ${average.toFixed(4)}ms average`);\n    return average;\n  }\n  \n  static compare(functions) {\n    const results = [];\n    \n    for (const [name, fn] of Object.entries(functions)) {\n      const time = this.measure(name, fn);\n      results.push({ name, time });\n    }\n    \n    results.sort((a, b) => a.time - b.time);\n    \n    console.log('\\nPerformance Ranking:');\n    results.forEach((result, index) => {\n      console.log(`${index + 1}. ${result.name}: ${result.time.toFixed(4)}ms`);\n    });\n    \n    return results;\n  }\n}\n\n// Example benchmarks\nconst testArray = Array.from({ length: 10000 }, (_, i) => i);\n\nconst functions = {\n  'forEach': () => {\n    let sum = 0;\n    testArray.forEach(num => sum += num);\n    return sum;\n  },\n  'for...of': () => {\n    let sum = 0;\n    for (const num of testArray) {\n      sum += num;\n    }\n    return sum;\n  },\n  'for loop': () => {\n    let sum = 0;\n    for (let i = 0; i < testArray.length; i++) {\n      sum += testArray[i];\n    }\n    return sum;\n  },\n  'reduce': () => {\n    return testArray.reduce((sum, num) => sum + num, 0);\n  }\n};\n\nArrayBenchmark.compare(functions);"},{title:"Memory Usage Monitoring",code:"// Memory usage monitoring\nclass MemoryMonitor {\n  static getMemoryUsage() {\n    if (performance.memory) {\n      return {\n        used: performance.memory.usedJSHeapSize,\n        total: performance.memory.totalJSHeapSize,\n        limit: performance.memory.jsHeapSizeLimit\n      };\n    }\n    return null;\n  }\n  \n  static logMemoryUsage(label = '') {\n    const usage = this.getMemoryUsage();\n    if (usage) {\n      console.log(`${label} Memory Usage:`, {\n        used: `${(usage.used / 1024 / 1024).toFixed(2)} MB`,\n        total: `${(usage.total / 1024 / 1024).toFixed(2)} MB`,\n        limit: `${(usage.limit / 1024 / 1024).toFixed(2)} MB`\n      });\n    }\n  }\n  \n  static measureMemoryImpact(fn) {\n    const before = this.getMemoryUsage();\n    const result = fn();\n    const after = this.getMemoryUsage();\n    \n    if (before && after) {\n      const difference = after.used - before.used;\n      console.log(`Memory impact: ${(difference / 1024).toFixed(2)} KB`);\n    }\n    \n    return result;\n  }\n}\n\n// Example usage\nMemoryMonitor.logMemoryUsage('Before operation');\n\nconst largeArray = Array.from({ length: 100000 }, (_, i) => i);\nMemoryMonitor.measureMemoryImpact(() => {\n  return largeArray.map(x => x * 2).filter(x => x % 2 === 0);\n});\n\nMemoryMonitor.logMemoryUsage('After operation');"}]}]}}]);
//# sourceMappingURL=2215.a7ac34e6.chunk.js.map