{"version":3,"file":"static/js/8958.43fe676d.chunk.js","mappings":"kIAAA,SACE,CACEA,MAAO,uBACPC,KAAK,ihBA0BP,CACED,MAAO,qBACPC,KAAK,u/BAiDP,CACED,MAAO,aACPC,KAAK,q7BA0CP,CACED,MAAO,sBACPC,KAAK,23CAiEP,CACED,MAAO,sBACPC,KAAK,ijD","sources":["data/go/advanced.ts"],"sourcesContent":["export default [\r\n  {\r\n    title: \"Context with Timeout\",\r\n    code: `package main\r\n\r\nimport (\r\n    \"context\"\r\n    \"fmt\"\r\n    \"time\"\r\n)\r\n\r\nfunc longRunningTask(ctx context.Context) string {\r\n    select {\r\n    case <-time.After(5 * time.Second):\r\n        return \"Task completed\"\r\n    case <-ctx.Done():\r\n        return \"Task cancelled: \" + ctx.Err().Error()\r\n    }\r\n}\r\n\r\nfunc main() {\r\n    // Create context with 3 second timeout\r\n    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\r\n    defer cancel()\r\n    \r\n    result := longRunningTask(ctx)\r\n    fmt.Println(result)\r\n}`\r\n  },\r\n  {\r\n    title: \"Custom Error Types\",\r\n    code: `package main\r\n\r\nimport (\r\n    \"fmt\"\r\n    \"time\"\r\n)\r\n\r\ntype ValidationError struct {\r\n    Field string\r\n    Value interface{}\r\n    Message string\r\n}\r\n\r\nfunc (e ValidationError) Error() string {\r\n    return fmt.Sprintf(\"validation error on %s: %v - %s\", e.Field, e.Value, e.Message)\r\n}\r\n\r\ntype AgeError struct {\r\n    Age int\r\n    Min int\r\n    Max int\r\n}\r\n\r\nfunc (e AgeError) Error() string {\r\n    return fmt.Sprintf(\"age %d is outside valid range [%d, %d]\", e.Age, e.Min, e.Max)\r\n}\r\n\r\nfunc validateAge(age int) error {\r\n    if age < 0 {\r\n        return &ValidationError{Field: \"age\", Value: age, Message: \"age cannot be negative\"}\r\n    }\r\n    if age > 150 {\r\n        return &AgeError{Age: age, Min: 0, Max: 150}\r\n    }\r\n    return nil\r\n}\r\n\r\nfunc main() {\r\n    ages := []int{25, -5, 200, 30}\r\n    \r\n    for _, age := range ages {\r\n        if err := validateAge(age); err != nil {\r\n            fmt.Printf(\"Error: %v\\\\n\", err)\r\n        } else {\r\n            fmt.Printf(\"Age %d is valid\\\\n\", age)\r\n        }\r\n    }\r\n}`\r\n  },\r\n  {\r\n    title: \"Reflection\",\r\n    code: `package main\r\n\r\nimport (\r\n    \"fmt\"\r\n    \"reflect\"\r\n)\r\n\r\ntype Person struct {\r\n    Name string \\`json:\"name\" validate:\"required\"\\`\r\n    Age  int    \\`json:\"age\" validate:\"min:0,max:150\"\\`\r\n    City string \\`json:\"city\"\\`\r\n}\r\n\r\nfunc inspectStruct(v interface{}) {\r\n    t := reflect.TypeOf(v)\r\n    v_val := reflect.ValueOf(v)\r\n    \r\n    fmt.Printf(\"Type: %s\\\\n\", t.Name())\r\n    fmt.Printf(\"Kind: %s\\\\n\", t.Kind())\r\n    fmt.Printf(\"Num fields: %d\\\\n\\\\n\", t.NumField())\r\n    \r\n    for i := 0; i < t.NumField(); i++ {\r\n        field := t.Field(i)\r\n        value := v_val.Field(i)\r\n        \r\n        fmt.Printf(\"Field: %s\\\\n\", field.Name)\r\n        fmt.Printf(\"  Type: %s\\\\n\", field.Type)\r\n        fmt.Printf(\"  Tag: %s\\\\n\", field.Tag)\r\n        fmt.Printf(\"  Value: %v\\\\n\\\\n\", value.Interface())\r\n    }\r\n}\r\n\r\nfunc main() {\r\n    person := Person{\r\n        Name: \"Alice\",\r\n        Age:  30,\r\n        City: \"New York\",\r\n    }\r\n    \r\n    inspectStruct(person)\r\n}`\r\n  },\r\n  {\r\n    title: \"Generics (Go 1.18+)\",\r\n    code: `package main\r\n\r\nimport \"fmt\"\r\n\r\n// Generic function that works with any comparable type\r\nfunc findIndex[T comparable](slice []T, item T) int {\r\n    for i, v := range slice {\r\n        if v == item {\r\n            return i\r\n        }\r\n    }\r\n    return -1\r\n}\r\n\r\n// Generic struct\r\ntype Stack[T any] struct {\r\n    items []T\r\n}\r\n\r\nfunc NewStack[T any]() *Stack[T] {\r\n    return &Stack[T]{items: make([]T, 0)}\r\n}\r\n\r\nfunc (s *Stack[T]) Push(item T) {\r\n    s.items = append(s.items, item)\r\n}\r\n\r\nfunc (s *Stack[T]) Pop() (T, bool) {\r\n    if len(s.items) == 0 {\r\n        var zero T\r\n        return zero, false\r\n    }\r\n    \r\n    item := s.items[len(s.items)-1]\r\n    s.items = s.items[:len(s.items)-1]\r\n    return item, true\r\n}\r\n\r\nfunc (s *Stack[T]) Size() int {\r\n    return len(s.items)\r\n}\r\n\r\nfunc main() {\r\n    // Using generic function\r\n    numbers := []int{1, 2, 3, 4, 5}\r\n    index := findIndex(numbers, 3)\r\n    fmt.Printf(\"Index of 3: %d\\\\n\", index)\r\n    \r\n    strings := []string{\"apple\", \"banana\", \"cherry\"}\r\n    strIndex := findIndex(strings, \"banana\")\r\n    fmt.Printf(\"Index of 'banana': %d\\\\n\", strIndex)\r\n    \r\n    // Using generic struct\r\n    intStack := NewStack[int]()\r\n    intStack.Push(1)\r\n    intStack.Push(2)\r\n    intStack.Push(3)\r\n    \r\n    fmt.Printf(\"Stack size: %d\\\\n\", intStack.Size())\r\n    \r\n    if item, ok := intStack.Pop(); ok {\r\n        fmt.Printf(\"Popped: %d\\\\n\", item)\r\n    }\r\n}`\r\n  },\r\n  {\r\n    title: \"Worker Pool Pattern\",\r\n    code: `package main\r\n\r\nimport (\r\n    \"fmt\"\r\n    \"sync\"\r\n    \"time\"\r\n)\r\n\r\ntype Job struct {\r\n    ID       int\r\n    Data     string\r\n    Duration time.Duration\r\n}\r\n\r\ntype Result struct {\r\n    JobID  int\r\n    Output string\r\n    Error  error\r\n}\r\n\r\nfunc worker(id int, jobs <-chan Job, results chan<- Result, wg *sync.WaitGroup) {\r\n    defer wg.Done()\r\n    \r\n    for job := range jobs {\r\n        fmt.Printf(\"Worker %d processing job %d\\\\n\", id, job.ID)\r\n        \r\n        // Simulate work\r\n        time.Sleep(job.Duration)\r\n        \r\n        result := Result{\r\n            JobID:  job.ID,\r\n            Output: fmt.Sprintf(\"Processed: %s\", job.Data),\r\n        }\r\n        \r\n        results <- result\r\n    }\r\n}\r\n\r\nfunc main() {\r\n    const numWorkers = 3\r\n    const numJobs = 10\r\n    \r\n    jobs := make(chan Job, numJobs)\r\n    results := make(chan Result, numJobs)\r\n    \r\n    var wg sync.WaitGroup\r\n    \r\n    // Start workers\r\n    for i := 1; i <= numWorkers; i++ {\r\n        wg.Add(1)\r\n        go worker(i, jobs, results, &wg)\r\n    }\r\n    \r\n    // Send jobs\r\n    for i := 1; i <= numJobs; i++ {\r\n        jobs <- Job{\r\n            ID:       i,\r\n            Data:     fmt.Sprintf(\"data-%d\", i),\r\n            Duration: time.Duration(i%3+1) * time.Second,\r\n        }\r\n    }\r\n    close(jobs)\r\n    \r\n    // Wait for all workers to finish\r\n    go func() {\r\n        wg.Wait()\r\n        close(results)\r\n    }()\r\n    \r\n    // Collect results\r\n    for result := range results {\r\n        fmt.Printf(\"Job %d completed: %s\\\\n\", result.JobID, result.Output)\r\n    }\r\n    \r\n    fmt.Println(\"All jobs completed!\")\r\n}`\r\n  }\r\n]; "],"names":["title","code"],"sourceRoot":""}